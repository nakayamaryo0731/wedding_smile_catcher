# 結婚式で笑顔を集める LINE Bot を作った話

## きっかけ

エムスリーテックブック 8 を読んでいたら、ある記事が目に止まった。

「結婚式でゲストの笑顔写真を集めて、AI でスコアリングしてランキング表示する」

なにそれ、めちゃくちゃ面白そう。

記事の著者は自分の結婚式でこのシステムを実際に使ったらしく、ゲストの 60%が参加して 368 枚の写真が集まったとのこと。しかもダウンタイムゼロ。

読み終わった瞬間、「これ、自分も作りたい」と思った。

元記事は AWS で実装されていたけど、自分は普段 GCP を使うことが多い。「GCP で作ったらどうなるんだろう？」という興味もあって、GCP 版として再実装してみることにした。

---

## 作りたかったもの

コンセプトはシンプル。

1. ゲストが LINE Bot に写真を送る
2. AI が「笑顔度」をスコアリング
3. 会場のスクリーンにリアルタイムでランキング表示

狙いは**ゲスト同士の交流促進**。

「笑顔が多いほど高得点」というルールにすると、自然と「みんなで撮ろう！」という空気が生まれる。新郎側・新婦側で分かれがちなゲスト同士が、写真をきっかけに話すようになる。

技術的なアーキテクチャはこんな感じ：

```text
LINE Bot → Cloud Functions → Cloud Vision API（笑顔検出）
                          → Vertex AI（テーマ評価）
                          → Firestore（スコア保存）
                                    ↓
                          Firebase Hosting（ランキング表示）
```

---

## 悩んだこと ①：スコアリングどうする？

点数のつけ方、めちゃくちゃ悩んだ。

最初は単純に「笑顔検出だけでいいじゃん」と思っていた。Cloud Vision API で顔を検出して、笑顔度（joyLikelihood）を取得すればいい。

でも、これだと問題があった。

**ドアップ写真が最強になってしまう。**

一人で満面の笑みでドアップ撮れば高得点。それじゃゲスト同士の交流は生まれない。

そこで、**人数が多いほど有利**になるようにした。

写真に写っている全員の笑顔スコアを**合算**する。5 人が笑っていれば、1 人の 5 倍のスコアになる可能性がある。

これで「グループで撮ろう」という動機が生まれる。

でも、まだ問題があった。

集合写真で後ろの方にいる人、顔が小さすぎて検出精度が落ちる。かといってドアップ写真と同じ扱いにすると、また 1 人写真が有利になってしまう。

そこで**顔サイズ係数**を導入した。

```python
# 顔サイズに応じた係数（0.5〜1.2）
# - 8%以上（ドアップ、1-2人）: 1.2
# - 5-8%（小グループ、3-4人）: 0.9〜1.2
# - 2-5%（中グループ、5-8人）: 0.6〜0.9
# - 1-2%（大グループ、10人以上）: 0.5〜0.6
# - 1%未満（遠景）: 0.5
```

係数の最大値を 1.2 にしたのは、ドアップ写真にもボーナスを与えるため。
顔がしっかり写っている方が表情もはっきり分かるので、その分を評価している。

さらに、Vision API の `detection_confidence`（顔検出の信頼度）も活用した。
同じ「VERY_LIKELY」でも、信頼度が高いほど確実な笑顔なので、
±10 点のボーナスを加算している。

```python
# detection_confidence (0〜1) を -10〜+10 のボーナスに変換
# 0.5 を基準とし、高いほどプラス、低いほどマイナス
confidence_bonus = (detection_confidence - 0.5) * 20
```

これでドアップと集合写真のバランスが取れた。

最終的なスコア計算式はこうなった：

```text
総合スコア = (笑顔スコア × AIスコア ÷ 100) × 類似度ペナルティ
```

---

## 悩んだこと ②：AI モデル選び

「結婚式っぽい写真かどうか」を判定するために、生成 AI を使うことにした。

最初は OpenAI の GPT-4o で試してみた。

結果、**GPT-4o は優しすぎた**。

どんな写真を送っても「素敵な写真ですね！」「とても良い表情です！」と高得点をつけてくる。変な写真でも 80 点とか出る。

これだとゲーミフィケーションにならない。みんな高得点だと面白くない。

そこで Google の Gemini に変更したら、適度にシビアな評価をしてくれるようになった。

ここで学んだのは、**AI モデルには「性格」がある**ということ。

用途によって合う合わないがある。今回のようなスコアリング用途では、厳しめの評価をしてくれるモデルの方が適していた。

---

## 悩んだこと ③：連写スパム対策

絶対いるでしょう、同じような写真を何枚も送る人。

連写して一番いい顔のやつだけ選ぶ、みたいな使い方をされると、他のゲストが不利になる。

そこで**Average Hash**（画像の指紋みたいなもの）を使って類似度を判定することにした。

似た写真が検出されたら、スコアを**1/3 にペナルティ**する。

「いろんなシーンを撮ってね」という行動を促す仕組み。

ハミング距離 8 をしきい値にして、それより近い画像は「類似」と判定している。

---

## 悩んだこと ④：絶対に落とせないプレッシャー

結婚式は一度きり。本番でバグったら終わり。

このプレッシャーが一番大きかった。

エラーハンドリングは徹底的に考えた。

- **Vision API 失敗** → 0 点（公平性のため）
- **Gemini 失敗** → 50 点（デフォルト値で救済）

Vision API が落ちたときに適当な点数をつけると不公平になる。だから 0 点。厳しいけど公平。

一方、Gemini の評価は「あったら嬉しい」程度の位置づけなので、失敗しても 50 点（中央値）で救済する。

リトライ戦略も入れた。**Exponential Backoff + Jitter**で、一時的な障害なら自動復旧する。

```python
# リトライ設定
max_retries = 5
base_delay = 2.0  # seconds
max_delay = 30.0  # seconds

# Exponential Backoff + Jitter
delay = min(base_delay * (2 ** attempt), max_delay)
jitter = random.uniform(0, delay * 0.1)  # 10% のランダム性
sleep_time = delay + jitter
```

あと、**並列処理**も重要だった。

```python
# Vision API、Gemini、ハッシュ計算を並列実行
with ThreadPoolExecutor(max_workers=3) as executor:
    vision_future = executor.submit(calculate_smile_score, image_bytes)
    theme_future = executor.submit(evaluate_theme, image_bytes)
    hash_future = executor.submit(calculate_average_hash, image_bytes)
```

結婚式の最中に「処理中...」で何秒も待たせたくない。並列処理でレイテンシを削減した。

---

## 作ってよかったこと

リアルタイムランキング、想像以上に盛り上がる。

Firestore のリアルタイムリスナーで、新しい高得点写真が入ると即座に画面が更新される。

1 位が変わると**紙吹雪エフェクト**が出る仕様にした。会場が「おお！」ってなる。

さらに、**スライドショーモード**も追加した。ランキング表示と自動的に切り替わって、投稿された写真をランダムに表示する機能。ランキングだけだと単調になりがちなので、雰囲気を変えるのに効果的だった。

何より嬉しかったのは、ゲスト同士が「一緒に撮ろう！」と声をかけ合うようになったこと。

新郎側・新婦側の垣根を超えて、みんなで写真を撮る。これがやりたかった。

---

## 技術スタック

最後に、使った技術をまとめておく。

| 役割       | 技術                          |
| ---------- | ----------------------------- |
| Bot        | LINE Messaging API            |
| Backend    | Cloud Functions (Python)      |
| 笑顔検出   | Cloud Vision API              |
| テーマ評価 | Vertex AI (Gemini 2.5 Flash)  |
| DB         | Firestore                     |
| 画像保存   | Cloud Storage                 |
| Frontend   | Vanilla JS + Firebase Hosting |
| IaC        | Terraform                     |
| CI/CD      | GitHub Actions                |

フロントエンドはあえて Vanilla JS にした。Next.js とか使うほどの規模じゃないし、シンプルな方がメンテしやすい。

---

## まとめ

技術書で見た「やってみたい」を形にできた。

結婚式 × テクノロジー、意外と相性がいい。ゲスト参加型の演出は、従来の「見るだけ」の結婚式とは違う体験を生み出せる。

同じようなことをやりたい人の参考になれば嬉しい。

<!-- リポジトリ公開する場合はここにリンク -->

---

_この記事は、エムスリーテックブック 8 第 2 章の内容に感銘を受けて書きました。元記事を書かれた中村伊吹さんに感謝します。_
